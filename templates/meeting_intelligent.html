<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Meeting Room - Intelligent Orchestration</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: system-ui, sans-serif;
            background: linear-gradient(135deg, #1e3a8a 0%, #7c3aed 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        header { text-align: center; color: white; margin-bottom: 30px; }
        h1 { font-size: 2.5rem; margin-bottom: 10px; }
        .subtitle { opacity: 0.9; font-size: 1.1rem; }

        /* Setup Screen */
        .setup-screen {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            margin-bottom: 20px;
            display: block;
        }

        .setup-screen.hidden {
            display: none;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            font-size: 1rem;
            font-family: inherit;
            transition: border-color 0.3s;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .form-group textarea {
            min-height: 100px;
            resize: vertical;
        }

        .form-group small {
            display: block;
            color: #6b7280;
            margin-top: 5px;
            font-size: 0.9rem;
        }

        .btn-launch {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 15px 50px;
            border: none;
            border-radius: 10px;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            margin-top: 10px;
        }

        .btn-launch:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(16, 185, 129, 0.4);
        }

        /* Meeting Room */
        .meeting-room {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            margin-bottom: 20px;
            display: none;
        }

        .meeting-room.active {
            display: block;
        }

        /* Agents Grid */
        .agents-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .agent-card {
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            border: 3px solid transparent;
            position: relative;
        }

        .agent-card.speaking {
            border-color: #10b981;
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(16, 185, 129, 0.4);
        }

        .agent-card.debate-mode {
            border-color: #f59e0b;
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
        }

        .relevance-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #3b82f6;
            color: white;
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 0.75rem;
            font-weight: 600;
            display: none;
        }

        .agent-card.speaking .relevance-badge { display: block; }

        .agent-avatar {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            margin: 0 auto 15px;
            transition: all 0.3s;
        }

        .agent-card.speaking .agent-avatar { animation: pulse 1.5s infinite; }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .agent-name {
            font-size: 1.2rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 5px;
        }

        .agent-role {
            font-size: 0.9rem;
            color: #6b7280;
        }

        /* Controls */
        .controls {
            text-align: center;
            margin-bottom: 30px;
        }

        .status {
            display: inline-block;
            padding: 15px 30px;
            border-radius: 10px;
            font-weight: 600;
            margin-bottom: 20px;
        }

        .status.disconnected { background: #fee2e2; color: #991b1b; }
        .status.connected { background: #d1fae5; color: #065f46; }
        .status.debate { background: #fef3c7; color: #92400e; }

        .queue-indicator {
            display: inline-block;
            margin-left: 10px;
            padding: 5px 12px;
            background: #dbeafe;
            color: #1e40af;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        button {
            padding: 15px 40px;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin: 0 10px;
        }

        .btn-start { background: #10b981; color: white; }
        .btn-start:hover { background: #059669; transform: translateY(-2px); }
        .btn-stop { background: #ef4444; color: white; display: none; }
        .btn-stop:hover { background: #dc2626; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Input */
        .input-section {
            margin-bottom: 20px;
            display: none;
        }

        .input-section.active { display: block; }

        .input-container {
            display: flex;
            gap: 10px;
        }

        input[type="text"] {
            flex: 1;
            padding: 15px;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            font-size: 1rem;
        }

        .btn-mic {
            background: #8b5cf6;
            color: white;
            padding: 15px 20px;
            border: none;
            border-radius: 10px;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-mic:hover { background: #7c3aed; }
        .btn-mic.recording {
            background: #ef4444;
            animation: pulse-mic 1s infinite;
        }

        @keyframes pulse-mic {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .btn-send {
            background: #3b82f6;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
        }

        .btn-send:hover { background: #2563eb; }

        /* Transcript */
        .transcript {
            background: #f9fafb;
            border-radius: 15px;
            padding: 25px;
            min-height: 300px;
            max-height: 400px;
            overflow-y: auto;
        }

        .transcript-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 15px;
        }

        .message {
            margin-bottom: 20px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .message-avatar {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }

        .message-name {
            font-weight: 700;
            font-size: 0.9rem;
        }

        .message-reasoning {
            font-size: 0.75rem;
            color: #6b7280;
            font-style: italic;
            margin-left: 5px;
        }

        .message-content {
            background: white;
            padding: 12px 15px;
            border-radius: 10px;
            margin-left: 40px;
            line-height: 1.6;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .message.user .message-content { background: #dbeafe; }
        .message.debate .message-content { border-left: 4px solid #f59e0b; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üé≠ AI Meeting Room</h1>
            <p class="subtitle">Orchestration intelligente avec d√©bat entre agents</p>
        </header>

        <!-- Setup Screen -->
        <div class="setup-screen" id="setupScreen">
            <h2 style="margin-bottom: 30px; color: #1f2937; text-align: center;">‚öôÔ∏è Configuration du Meeting</h2>

            <form id="setupForm">
                <div class="form-group">
                    <label for="companyName">Nom de l'entreprise / Projet</label>
                    <input
                        type="text"
                        id="companyName"
                        placeholder="Ex: TechStartup, MonProjetApp, etc."
                        required
                    >
                    <small>Le nom de votre entreprise ou projet</small>
                </div>

                <div class="form-group">
                    <label for="companyContext">Contexte de l'entreprise</label>
                    <textarea
                        id="companyContext"
                        placeholder="D√©crivez votre entreprise, son secteur d'activit√©, sa taille, ses produits/services..."
                        required
                    ></textarea>
                    <small>Donnez du contexte pour que les agents comprennent votre situation</small>
                </div>

                <div class="form-group">
                    <label for="meetingObjective">Objectif de la r√©union</label>
                    <textarea
                        id="meetingObjective"
                        placeholder="Que souhaitez-vous accomplir dans ce meeting ? Ex: D√©finir la strat√©gie de lancement d'un nouveau produit, analyser la faisabilit√© technique d'une id√©e, etc."
                        required
                    ></textarea>
                    <small>Soyez pr√©cis sur ce que vous attendez de cette session</small>
                </div>

                <button type="submit" class="btn-launch">üöÄ Lancer le Meeting</button>
            </form>
        </div>

        <div class="meeting-room" id="meetingRoom">
            <!-- Agents Grid -->
            <div class="agents-grid">
                <div class="agent-card" id="agent-facilitateur">
                    <span class="relevance-badge" id="badge-facilitateur">Score: --</span>
                    <div class="agent-avatar">üéØ</div>
                    <div class="agent-name">Facilitateur</div>
                    <div class="agent-role">Animateur de r√©union</div>
                </div>

                <div class="agent-card" id="agent-strategie">
                    <span class="relevance-badge" id="badge-strategie">Score: --</span>
                    <div class="agent-avatar">üìä</div>
                    <div class="agent-name">Strat√®ge Business</div>
                    <div class="agent-role">Consultant en strat√©gie</div>
                </div>

                <div class="agent-card" id="agent-tech">
                    <span class="relevance-badge" id="badge-tech">Score: --</span>
                    <div class="agent-avatar">üíª</div>
                    <div class="agent-name">Tech Lead</div>
                    <div class="agent-role">Architecte technique</div>
                </div>

                <div class="agent-card" id="agent-creatif">
                    <span class="relevance-badge" id="badge-creatif">Score: --</span>
                    <div class="agent-avatar">üí°</div>
                    <div class="agent-name">Creative Thinker</div>
                    <div class="agent-role">Innovation & Design</div>
                </div>
            </div>

            <!-- Controls -->
            <div class="controls">
                <div class="status disconnected" id="status">üî¥ Meeting non d√©marr√©</div>
                <span class="queue-indicator" id="queueIndicator" style="display: none;">Queue: 0</span>
                <br>
                <button class="btn-start" id="startBtn">D√©marrer le Meeting</button>
                <button class="btn-stop" id="stopBtn">Terminer le Meeting</button>
            </div>

            <!-- Input Section -->
            <div class="input-section" id="inputSection">
                <div class="input-container">
                    <input type="text" id="userInput" placeholder="Posez votre question ou lancez un sujet...">
                    <button class="btn-mic" id="micBtn">üé§</button>
                    <button class="btn-send" id="sendBtn">Envoyer</button>
                </div>
            </div>

            <!-- Transcript -->
            <div class="transcript" id="transcript">
                <div class="transcript-title">üìù Transcript du Meeting</div>
                <div style="text-align: center; color: #9ca3af; padding: 40px 20px;">
                    Le meeting n'a pas encore commenc√©...<br>
                    <small>Cliquez sur "D√©marrer le Meeting" pour commencer</small>
                </div>
            </div>
        </div>
    </div>

    <script>
        const AGENTS = {
            facilitateur: { id: 'facilitateur', name: 'Facilitateur', emoji: 'üéØ', color: '#06b6d4' },
            strategie: { id: 'strategie', name: 'Strat√®ge Business', emoji: 'üìä', color: '#ec4899' },
            tech: { id: 'tech', name: 'Tech Lead', emoji: 'üíª', color: '#10b981' },
            creatif: { id: 'creatif', name: 'Creative Thinker', emoji: 'üí°', color: '#f59e0b' }
        };

        let isRunning = false;
        let sessionId = null;
        let maxTurns = 20;  // Plus de tours pour des discussions riches
        let currentTurn = 0;

        // Contexte du meeting
        let meetingContext = {
            companyName: '',
            companyContext: '',
            meetingObjective: ''
        };

        const setupScreen = document.getElementById('setupScreen');
        const meetingRoom = document.getElementById('meetingRoom');
        const setupForm = document.getElementById('setupForm');
        const status = document.getElementById('status');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const transcript = document.getElementById('transcript');
        const inputSection = document.getElementById('inputSection');
        const userInput = document.getElementById('userInput');
        const sendBtn = document.getElementById('sendBtn');
        const micBtn = document.getElementById('micBtn');
        const queueIndicator = document.getElementById('queueIndicator');

        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;

        // Queue audio pour √©viter les chevauchements
        let audioQueue = [];
        let isPlayingAudio = false;
        let currentAudio = null;

        // Gestion du formulaire de setup
        setupForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            // R√©cup√©rer les valeurs
            meetingContext.companyName = document.getElementById('companyName').value.trim();
            meetingContext.companyContext = document.getElementById('companyContext').value.trim();
            meetingContext.meetingObjective = document.getElementById('meetingObjective').value.trim();

            // Validation
            if (!meetingContext.companyName || !meetingContext.companyContext || !meetingContext.meetingObjective) {
                alert('Veuillez remplir tous les champs');
                return;
            }

            // Transition vers la meeting room
            setupScreen.classList.add('hidden');
            meetingRoom.classList.add('active');

            // Lancer automatiquement le meeting
            await startMeeting();
        });

        function updateStatus(text, className) {
            status.textContent = text;
            status.className = 'status ' + className;
        }

        function highlightAgent(agentId, reasoning = null) {
            document.querySelectorAll('.agent-card').forEach(card => {
                card.classList.remove('speaking');
            });

            if (agentId) {
                const agentCard = document.getElementById(`agent-${agentId}`);
                if (agentCard) {
                    agentCard.classList.add('speaking');
                    if (reasoning) {
                        const badge = document.getElementById(`badge-${agentId}`);
                        if (badge) badge.textContent = reasoning;
                    }
                }
            }
        }

        function setDebateMode(enabled) {
            document.querySelectorAll('.agent-card').forEach(card => {
                if (enabled) {
                    card.classList.add('debate-mode');
                } else {
                    card.classList.remove('debate-mode');
                }
            });

            if (enabled) {
                updateStatus('üí¨ Mode d√©bat activ√©!', 'debate');
            }
        }

        function addMessage(agentId, content, reasoning = null, isDebate = false) {
            const isEmpty = transcript.querySelector('[style*="center"]');
            if (isEmpty) {
                transcript.innerHTML = '<div class="transcript-title">üìù Transcript du Meeting</div>';
            }

            const agent = agentId === 'user' ? {
                name: 'Vous',
                emoji: 'üë§',
                color: '#3b82f6'
            } : AGENTS[agentId];

            const msg = document.createElement('div');
            msg.className = 'message ' + agentId + (isDebate ? ' debate' : '');
            msg.innerHTML = `
                <div class="message-header">
                    <div class="message-avatar" style="background: ${agent.color}">${agent.emoji}</div>
                    <div class="message-name" style="color: ${agent.color}">${agent.name}</div>
                    ${reasoning ? `<span class="message-reasoning">${reasoning}</span>` : ''}
                </div>
                <div class="message-content">${content}</div>
            `;
            transcript.appendChild(msg);
            transcript.scrollTop = transcript.scrollHeight;
        }

        // Mettre √† jour l'indicateur de queue
        function updateQueueIndicator() {
            if (audioQueue.length > 0) {
                queueIndicator.textContent = `üîä Queue: ${audioQueue.length}`;
                queueIndicator.style.display = 'inline-block';
            } else {
                queueIndicator.style.display = 'none';
            }
        }

        // Syst√®me de queue audio pour √©viter les chevauchements
        function addToAudioQueue(agentId, text) {
            audioQueue.push({ agentId, text });
            console.log(`üì• Audio ajout√© √† la queue (${audioQueue.length} en attente)`);
            updateQueueIndicator();

            // Si rien n'est en cours de lecture, d√©marrer
            if (!isPlayingAudio) {
                playNextInQueue();
            }
        }

        async function playNextInQueue() {
            if (audioQueue.length === 0) {
                isPlayingAudio = false;
                updateQueueIndicator();
                console.log('‚úÖ Queue audio vide');

                // Continuer le meeting automatiquement (d√©lai r√©duit)
                if (isRunning && currentTurn < maxTurns) {
                    setTimeout(() => nextTurn(), 500);  // 500ms au lieu de 1500ms
                }
                return;
            }

            isPlayingAudio = true;
            const { agentId, text } = audioQueue.shift();
            updateQueueIndicator();

            console.log(`üîä Lecture: ${agentId} - "${text.substring(0, 50)}..."`);

            try {
                const response = await fetch('http://localhost:5000/api/speak', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text, agent: agentId })
                });

                if (!response.ok) throw new Error('Failed to generate speech');

                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);

                // Arr√™ter tout audio en cours (s√©curit√©)
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio = null;
                }

                currentAudio = new Audio(audioUrl);

                currentAudio.onended = () => {
                    URL.revokeObjectURL(audioUrl);
                    highlightAgent(null);
                    currentAudio = null;
                    console.log(`‚úÖ Audio termin√©: ${agentId}`);

                    // Jouer le prochain dans la queue (imm√©diat)
                    setTimeout(() => playNextInQueue(), 100);  // 100ms au lieu de 500ms
                };

                currentAudio.onerror = (error) => {
                    console.error('‚ùå Erreur lecture audio:', error);
                    URL.revokeObjectURL(audioUrl);
                    currentAudio = null;

                    // Continuer avec le suivant
                    setTimeout(() => playNextInQueue(), 500);
                };

                await currentAudio.play();

            } catch (error) {
                console.error('‚ùå Erreur g√©n√©ration audio:', error);
                highlightAgent(null);

                // Continuer avec le suivant
                setTimeout(() => playNextInQueue(), 500);
            }
        }

        async function generateAndPlaySpeech(agentId, text) {
            // Ajouter √† la queue au lieu de jouer directement
            addToAudioQueue(agentId, text);
        }

        function stopAllAudio() {
            // Vider la queue
            audioQueue = [];

            // Arr√™ter l'audio en cours
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }

            isPlayingAudio = false;
            console.log('‚èπÔ∏è Tous les audios arr√™t√©s');
        }

        async function initOrchestrator() {
            try {
                // Envoyer le contexte du meeting √† l'orchestrateur
                const response = await fetch('/api/orchestrator/init', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify({
                        context: meetingContext
                    })
                });

                const data = await response.json();
                if (data.success) {
                    sessionId = data.session_id;
                    console.log('‚úÖ Orchestrateur initialis√© avec contexte:', sessionId);
                    console.log('üìã Contexte:', meetingContext);
                    return true;
                }
                return false;
            } catch (error) {
                console.error('‚ùå Erreur init orchestrateur:', error);
                return false;
            }
        }

        async function addUserMessage(message) {
            try {
                const response = await fetch('/api/orchestrator/add_message', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify({ message: message })
                });

                const data = await response.json();
                return data.success;
            } catch (error) {
                console.error('‚ùå Erreur ajout message:', error);
                return false;
            }
        }

        async function nextTurn() {
            if (!isRunning || currentTurn >= maxTurns) {
                endMeeting();
                return;
            }

            try {
                updateStatus('ü§î S√©lection du prochain agent...', 'connected');

                const response = await fetch('/api/orchestrator/next_turn', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin'
                });

                const data = await response.json();

                if (data.success) {
                    currentTurn = data.turn;
                    const { agent_id, message, reasoning, debate_mode } = data;

                    console.log(`üéØ Tour ${currentTurn}: ${agent_id} - ${reasoning}`);

                    highlightAgent(agent_id, `Pertinence: ${reasoning.substring(0, 30)}...`);
                    addMessage(agent_id, message, reasoning, debate_mode);
                    setDebateMode(debate_mode);

                    // G√©n√©rer et jouer l'audio
                    generateAndPlaySpeech(agent_id, message);

                } else {
                    console.error('‚ùå Erreur orchestration:', data.error);
                    endMeeting();
                }

            } catch (error) {
                console.error('‚ùå Erreur nextTurn:', error);
                endMeeting();
            }
        }

        async function startMeeting() {
            // Initialiser l'orchestrateur
            const initialized = await initOrchestrator();
            if (!initialized) {
                alert('Erreur lors de l\'initialisation de l\'orchestrateur');
                return;
            }

            isRunning = true;
            currentTurn = 0;

            updateStatus('üü¢ Meeting en cours', 'connected');
            startBtn.style.display = 'none';
            stopBtn.style.display = 'inline-block';
            inputSection.classList.add('active');

            // Message d'introduction avec le contexte
            const introMessage = `Bonjour! Je suis ${meetingContext.companyName}. ${meetingContext.companyContext}\n\nObjectif de cette r√©union: ${meetingContext.meetingObjective}`;

            addMessage('user', introMessage, null, false);
            await addUserMessage(introMessage);

            // Premier tour
            setTimeout(() => nextTurn(), 1000);
        }

        function endMeeting() {
            isRunning = false;

            // Arr√™ter tous les audios en cours
            stopAllAudio();

            highlightAgent(null);
            setDebateMode(false);
            updateStatus('üî¥ Meeting termin√©', 'disconnected');
            startBtn.style.display = 'inline-block';
            stopBtn.style.display = 'none';
            inputSection.classList.remove('active');

            // Reset orchestrateur
            fetch('/api/orchestrator/reset', {
                method: 'POST',
                credentials: 'same-origin'
            });
        }

        async function sendUserMessage() {
            const message = userInput.value.trim();
            if (!message) return;

            addMessage('user', message);
            await addUserMessage(message);

            userInput.value = '';

            // D√©clencher le prochain tour
            setTimeout(() => nextTurn(), 500);
        }

        // Fonctions de gestion du micro
        async function toggleRecording() {
            if (!isRecording) {
                await startRecording();
            } else {
                await stopRecording();
            }
        }

        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];

                mediaRecorder.addEventListener('dataavailable', event => {
                    audioChunks.push(event.data);
                });

                mediaRecorder.addEventListener('stop', async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    await transcribeAudio(audioBlob);

                    // Arr√™ter le stream
                    stream.getTracks().forEach(track => track.stop());
                });

                mediaRecorder.start();
                isRecording = true;
                micBtn.classList.add('recording');
                micBtn.textContent = '‚èπÔ∏è';
                console.log('üé§ Enregistrement d√©marr√©');

            } catch (error) {
                console.error('‚ùå Erreur micro:', error);
                alert('Impossible d\'acc√©der au microphone. V√©rifiez les permissions.');
            }
        }

        async function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                micBtn.classList.remove('recording');
                micBtn.textContent = 'üé§';
                console.log('‚èπÔ∏è Enregistrement arr√™t√©');
            }
        }

        async function transcribeAudio(audioBlob) {
            try {
                updateStatus('üé§ Transcription en cours...', 'connected');

                // Convertir en WAV si n√©cessaire (optionnel, Whisper accepte WebM)
                const formData = new FormData();
                formData.append('audio', audioBlob, 'recording.webm');

                const response = await fetch('/api/transcribe', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (data.success && data.text) {
                    console.log('üìù Transcription:', data.text);
                    userInput.value = data.text;

                    // Envoyer automatiquement
                    await sendUserMessage();
                } else {
                    console.error('‚ùå Erreur transcription:', data.error);
                    updateStatus('‚ùå Erreur de transcription', 'disconnected');
                }

            } catch (error) {
                console.error('‚ùå Erreur transcription:', error);
                updateStatus('‚ùå Erreur de transcription', 'disconnected');
            }
        }

        startBtn.addEventListener('click', startMeeting);
        stopBtn.addEventListener('click', endMeeting);
        sendBtn.addEventListener('click', sendUserMessage);
        micBtn.addEventListener('click', toggleRecording);
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendUserMessage();
        });
    </script>
</body>
</html>
